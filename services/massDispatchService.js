const MassDispatch = require('../models/MassDispatch');
const evolutionApi = require('./evolutionApi');
const phoneService = require('./phoneService');
const socketManager = require('../utils/socketManager');
const templateUtils = require('../utils/templateUtils');

class MassDispatchService {
  constructor() {
    this.activeDispatches = new Map(); // instanceName -> dispatchId
    this.timers = new Map(); // dispatchId -> timer
  }

  /**
   * Cria um novo disparo em massa
   * @param {object} data - Dados do disparo
   * @returns {object} - Disparo criado
   */
  async createDispatch(data) {
    const dispatch = new MassDispatch(data);
    await dispatch.save();
    return dispatch;
  }

  /**
   * Processa e valida n√∫meros de telefone
   * @param {string} dispatchId - ID do disparo
   * @param {Array} rawNumbers - N√∫meros brutos
   * @returns {object} - Resultado do processamento
   */
  async processNumbers(dispatchId, rawNumbers) {
    const dispatch = await MassDispatch.findById(dispatchId);
    if (!dispatch) throw new Error('Disparo n√£o encontrado');

    dispatch.status = 'validating';
    await dispatch.save();

    // Processar n√∫meros
    const processedNumbers = phoneService.processPhoneList(rawNumbers);
    
    // Preparar lista para valida√ß√£o no WhatsApp
    const numbersToValidate = processedNumbers
      .filter(p => p.isValid)
      .map(p => p.formatted);

    let validatedNumbers = [];
    
    if (dispatch.settings.validateNumbers && numbersToValidate.length > 0) {
      try {
        // Validar n√∫meros no WhatsApp
        const validationResult = await evolutionApi.checkWhatsAppNumbers(
          dispatch.instanceName, 
          numbersToValidate
        );
        
        validatedNumbers = validationResult.map(result => ({
          number: result.jid.split('@')[0],
          exists: result.exists,
          name: result.name || null // Armazenar o nome do contato
        }));
      } catch (error) {
        console.error('Erro na valida√ß√£o WhatsApp:', error);
        // Se falhar na valida√ß√£o, assumir que todos s√£o v√°lidos
        validatedNumbers = numbersToValidate.map(num => ({
          number: num,
          exists: true,
          name: null // Sem nome quando falha a valida√ß√£o
        }));
      }
    } else {
      // Se n√£o validar, assumir que todos os n√∫meros formatados s√£o v√°lidos
      validatedNumbers = numbersToValidate.map(num => ({
        number: num,
        exists: true,
        name: null // Sem nome quando n√£o h√° valida√ß√£o
      }));
    }

    // Criar lista final de n√∫meros
    const finalNumbers = processedNumbers.map(processed => {
      const validation = validatedNumbers.find(v => v.number === processed.formatted);
      
      return {
        original: processed.original,
        formatted: processed.formatted,
        valid: processed.isValid && (validation ? validation.exists : true),
        contactName: validation ? validation.name : null, // Armazenar nome do contato
        status: 'pending'
      };
    });

    // Atualizar disparo
    dispatch.numbers = finalNumbers;
    dispatch.updateStatistics();
    dispatch.status = 'ready';
    await dispatch.save();

    // Notificar via WebSocket
    socketManager.emitToUser(dispatch.userId, 'mass-dispatch-updated', {
      dispatchId: dispatch._id,
      status: dispatch.status,
      statistics: dispatch.statistics
    });

    return {
      dispatch,
      statistics: phoneService.generateStats(processedNumbers)
    };
  }

  /**
   * Inicia um disparo em massa
   * @param {string} dispatchId - ID do disparo
   * @returns {object} - Status do in√≠cio
   */
  async startDispatch(dispatchId) {
    const dispatch = await MassDispatch.findById(dispatchId);
    if (!dispatch) throw new Error('Disparo n√£o encontrado');

    if (dispatch.status !== 'ready') {
      throw new Error('Disparo n√£o est√° pronto para execu√ß√£o');
    }

    // Verificar se j√° existe um disparo ativo para esta inst√¢ncia
    if (this.activeDispatches.has(dispatch.instanceName)) {
      throw new Error('J√° existe um disparo ativo para esta inst√¢ncia');
    }

    // Verificar se est√° no hor√°rio permitido
    if (!dispatch.isWithinSchedule()) {
      dispatch.status = 'scheduled';
      dispatch.nextScheduledRun = this.calculateNextRun(dispatch);
      await dispatch.save();
      
      // Agendar para pr√≥ximo hor√°rio v√°lido
      this.scheduleDispatch(dispatchId);
      
      return { 
        success: true, 
        message: 'Disparo agendado para pr√≥ximo hor√°rio v√°lido',
        nextRun: dispatch.nextScheduledRun
      };
    }

    // Iniciar disparo
    dispatch.status = 'running';
    dispatch.isActive = true;
    dispatch.startedAt = new Date();
    dispatch.currentIndex = 0;
    await dispatch.save();

    // Registrar disparo ativo
    this.activeDispatches.set(dispatch.instanceName, dispatchId);

    // Iniciar processo de envio
    this.processDispatch(dispatchId);

    // Notificar via WebSocket
    socketManager.emitToUser(dispatch.userId, 'mass-dispatch-started', {
      dispatchId: dispatch._id,
      instanceName: dispatch.instanceName
    });

    return { success: true, message: 'Disparo iniciado com sucesso' };
  }

  /**
   * Processa o disparo enviando mensagens
   * @param {string} dispatchId - ID do disparo
   */
  async processDispatch(dispatchId) {
    console.log(`üîÑ === INICIANDO PROCESSAMENTO DISPARO ${dispatchId} ===`);
    
    const dispatch = await MassDispatch.findById(dispatchId);
    if (!dispatch || !dispatch.isActive) {
      console.log(`‚ùå Disparo ${dispatchId} n√£o encontrado ou inativo:`, { found: !!dispatch, active: dispatch?.isActive });
      return;
    }

    console.log(`üìä Status do disparo:`, {
      name: dispatch.name,
      status: dispatch.status,
      isActive: dispatch.isActive,
      currentIndex: dispatch.currentIndex,
      totalNumbers: dispatch.numbers.length
    });

    const validNumbers = dispatch.numbers.filter(n => n.valid && n.status === 'pending');
    console.log(`üìã N√∫meros v√°lidos pendentes: ${validNumbers.length}`);
    
    validNumbers.forEach((num, idx) => {
      console.log(`  ${idx}: ${num.original} -> ${num.formatted} [${num.status}]`);
    });
    
    // Verificar se ainda h√° n√∫meros pendentes para processar
    if (validNumbers.length === 0) {
      console.log(`‚úÖ Todos os n√∫meros processados. Finalizando disparo.`);
      // Disparo conclu√≠do
      return this.completeDispatch(dispatchId);
    }
    
    // Encontrar o n√∫mero atual baseado no currentIndex
    const currentNumber = dispatch.numbers[dispatch.currentIndex];
    console.log(`üîç N√∫mero no √≠ndice ${dispatch.currentIndex}:`, {
      original: currentNumber?.original,
      formatted: currentNumber?.formatted,
      status: currentNumber?.status,
      valid: currentNumber?.valid
    });
    
    // Se o n√∫mero atual n√£o est√° pendente, procurar o pr√≥ximo pendente
    if (!currentNumber || currentNumber.status !== 'pending' || !currentNumber.valid) {
      console.log(`‚è≠Ô∏è N√∫mero atual n√£o √© pendente. Procurando pr√≥ximo...`);
      
      // Encontrar pr√≥ximo n√∫mero pendente
      const nextPendingIndex = dispatch.numbers.findIndex((num, idx) => 
        idx > dispatch.currentIndex && num.valid && num.status === 'pending'
      );
      
      if (nextPendingIndex === -1) {
        console.log(`‚úÖ N√£o h√° mais n√∫meros pendentes. Finalizando disparo.`);
        return this.completeDispatch(dispatchId);
      }
      
      console.log(`üìç Pr√≥ximo n√∫mero pendente encontrado no √≠ndice: ${nextPendingIndex}`);
      dispatch.currentIndex = nextPendingIndex;
      await dispatch.save();
      
      // Chamar novamente com o novo √≠ndice
      return this.processDispatch(dispatchId);
    }

    // Verificar se ainda est√° no hor√°rio permitido
    if (!dispatch.isWithinSchedule()) {
      console.log(`‚è∞ Fora do hor√°rio permitido. Pausando disparo.`);
      return this.pauseDispatch(dispatchId, 'Fora do hor√°rio permitido');
    }

    console.log(`üéØ Processando n√∫mero no √≠ndice ${dispatch.currentIndex}: ${currentNumber.original} -> ${currentNumber.formatted}`);
    
    try {
      console.log(`üì§ Tentando enviar para: ${currentNumber.formatted}`);
      
      // Enviar mensagem e aguardar confirma√ß√£o
      const sendResult = await this.sendMessage(dispatch, currentNumber);
      console.log(`‚úÖ Mensagem enviada com sucesso para: ${currentNumber.formatted}`, sendResult);
      
      // Atualizar status APENAS ap√≥s confirma√ß√£o de envio
      currentNumber.status = 'sent';
      currentNumber.sentAt = new Date();
      
      // Salvar no banco ANTES de continuar
      dispatch.currentIndex++;
      dispatch.updateStatistics();
      await dispatch.save();
      console.log(`üíæ Status salvo no banco para: ${currentNumber.formatted}`);

      // Notificar progresso
      socketManager.emitToUser(dispatch.userId, 'mass-dispatch-progress', {
        dispatchId: dispatch._id,
        progress: {
          current: dispatch.currentIndex,
          total: validNumbers.length,
          percentage: Math.round((dispatch.currentIndex / validNumbers.length) * 100)
        },
        statistics: dispatch.statistics
      });

      // Agendar pr√≥ximo envio APENAS ap√≥s sucesso confirmado
      const delay = dispatch.getNextDelay();
      console.log(`‚è±Ô∏è Pr√≥ximo envio em ${delay}ms`);
      
      const timer = setTimeout(() => {
        this.processDispatch(dispatchId);
      }, delay);
      
      this.timers.set(dispatchId, timer);

    } catch (error) {
      console.error(`‚ùå ERRO ao enviar para ${currentNumber.formatted}:`, error.message);
      
      // Marcar como falha com detalhes do erro
      currentNumber.status = 'failed';
      currentNumber.error = error.message;
      currentNumber.failedAt = new Date();
      
      // Salvar no banco ANTES de continuar
      dispatch.currentIndex++;
      dispatch.updateStatistics();
      await dispatch.save();
      console.log(`üíæ Erro salvo no banco para: ${currentNumber.formatted}`);

      // Notificar erro
      socketManager.emitToUser(dispatch.userId, 'mass-dispatch-error', {
        dispatchId: dispatch._id,
        number: currentNumber.formatted,
        error: error.message,
        statistics: dispatch.statistics
      });

      // Continuar com pr√≥ximo n√∫mero ap√≥s delay menor
      console.log(`‚è±Ô∏è Tentando pr√≥ximo n√∫mero em 5 segundos ap√≥s erro`);
      const timer = setTimeout(() => {
        this.processDispatch(dispatchId);
      }, 5000); // 5 segundos em caso de erro
      
      this.timers.set(dispatchId, timer);
    }
  }

  /**
   * Envia mensagem baseada no template
   * @param {object} dispatch - Disparo
   * @param {object} numberData - Dados do n√∫mero
   */
  async sendMessage(dispatch, numberData) {
    const { template } = dispatch;
    const { formatted: number, contactName, original } = numberData;

    console.log(`üîç Debug sendMessage:`, {
      dispatchId: dispatch._id,
      templateType: template?.type,
      hasTemplate: !!template,
      templateStructure: template,
      number: number
    });

    try {
      let result;

      // Preparar vari√°veis para substitui√ß√£o
      const variables = {
        name: contactName,
        contactName: contactName,
        number: number,
        originalNumber: original,
        formatted: number,
        original: original
      };

      // Obter nome padr√£o das configura√ß√µes
      const defaultName = dispatch.settings?.personalization?.defaultName || 'Cliente';

      // Processar template com vari√°veis (sempre ativo)
      const processedTemplate = templateUtils.processTemplate(template, variables, defaultName);
      
      if (processedTemplate.type === 'sequence') {
        // Debug: verificar estrutura da sequ√™ncia
        console.log(`üîç Debug sequ√™ncia para ${number}:`, {
          templateType: processedTemplate.type,
          hasSequence: !!processedTemplate.sequence,
          sequenceMessages: processedTemplate.sequence?.messages?.length || 0,
          sequenceStructure: processedTemplate.sequence
        });
        
        // Debug: verificar o que est√° sendo passado para sendMessageSequence
        console.log(`üîç Debug antes de sendMessageSequence:`, {
          processedSequenceFirstMessage: processedTemplate.sequence?.messages?.[0]?.content?.text,
          processedSequenceStructure: processedTemplate.sequence
        });
        
        // Enviar sequ√™ncia de mensagens
        result = await this.sendMessageSequence(dispatch.instanceName, number, processedTemplate.sequence, variables, defaultName);
        console.log(`üé≠ Sequ√™ncia enviada para ${number}:`, {
          messagesCount: processedTemplate.sequence?.messages?.length || 0,
          contactName: contactName || 'N/A',
          defaultName: defaultName
        });
      } else {
        // Enviar mensagem simples
        console.log(`üé≠ Template personalizado para ${number}:`, {
          originalText: template.content?.text,
          processedText: processedTemplate.content?.text,
          contactName: contactName || 'N/A',
          defaultName: defaultName
        });

        switch (processedTemplate.type) {
          case 'text':
            result = await evolutionApi.sendTextMessage(
              dispatch.instanceName,
              number,
              processedTemplate.content.text
            );
            break;

          case 'image':
            result = await evolutionApi.sendMedia(
              dispatch.instanceName,
              number,
              processedTemplate.content.media,
              'image'
            );
            break;

          case 'image_caption':
            result = await evolutionApi.sendMedia(
              dispatch.instanceName,
              number,
              processedTemplate.content.media,
              'image',
              processedTemplate.content.caption
            );
            break;

          case 'audio':
            result = await evolutionApi.sendAudioUrl(
              dispatch.instanceName,
              number,
              processedTemplate.content.media
            );
            break;

          case 'file':
            result = await evolutionApi.sendMedia(
              dispatch.instanceName,
              number,
              processedTemplate.content.media,
              'document',
              '',
              processedTemplate.content.fileName
            );
            break;

          case 'file_caption':
            result = await evolutionApi.sendMedia(
              dispatch.instanceName,
              number,
              processedTemplate.content.media,
              'document',
              processedTemplate.content.caption,
              processedTemplate.content.fileName
            );
            break;

          default:
            throw new Error(`Tipo de template n√£o suportado: ${processedTemplate.type}`);
        }
      }

      // Validar resposta da API
      if (!result) {
        throw new Error('API retornou resposta vazia');
      }

      // Log de sucesso detalhado
      console.log(`üì® Resposta da API para ${number}:`, JSON.stringify(result, null, 2));

      return result;

    } catch (error) {
      // Log detalhado do erro
      console.error(`üö´ Erro detalhado ao enviar para ${number}:`, {
        templateType: template.type,
        error: error.message,
        stack: error.stack
      });
      
      // Re-throw com contexto adicional
      throw new Error(`Falha ao enviar ${template.type} para ${number}: ${error.message}`);
    }
  }

  /**
   * Envia sequ√™ncia de mensagens para um n√∫mero
   * @param {string} instanceName - Nome da inst√¢ncia
   * @param {string} number - N√∫mero de destino
   * @param {object} sequence - Sequ√™ncia de mensagens
   * @param {object} variables - Vari√°veis para substitui√ß√£o
   * @param {string} defaultName - Nome padr√£o
   * @returns {Array} - Resultados das mensagens enviadas
   */
  async sendMessageSequence(instanceName, number, sequence, variables = {}, defaultName = 'Cliente') {
    console.log(`üîç Debug sendMessageSequence recebido:`, {
      instanceName,
      number,
      hasSequence: !!sequence,
      sequenceMessages: sequence?.messages?.length || 0,
      firstMessageText: sequence?.messages?.[0]?.content?.text,
      sequenceStructure: sequence
    });
    
    const results = [];
    
    // Verificar se sequence e messages existem
    if (!sequence || !sequence.messages || sequence.messages.length === 0) {
      console.log(`‚ùå Sequ√™ncia vazia ou inv√°lida para ${number}`);
      return {
        success: false,
        messages: [],
        totalSent: 0,
        totalFailed: 0,
        error: 'Sequ√™ncia vazia ou inv√°lida'
      };
    }
    
    // Ordenar mensagens por ordem
    const sortedMessages = sequence.messages.sort((a, b) => a.order - b.order);
    
    for (let i = 0; i < sortedMessages.length; i++) {
      const message = sortedMessages[i];
      
      // Extrair dados corretos do objeto Mongoose DocumentArray
      const messageData = message._doc || message;
      const order = messageData.order;
      const type = messageData.type;
      const delay = messageData.delay;
      const content = message.content; // Usar o conte√∫do processado
      
      console.log(`üîç Debug mensagem ${i} (processada):`, {
        messageOrder: order,
        messageType: type,
        messageDelay: delay,
        messageContent: content,
        messageData: messageData,
        rawMessage: message
      });
      
      // Validar se a mensagem tem os campos obrigat√≥rios
      if (!order || !type) {
        console.log(`‚ùå Mensagem ${i} inv√°lida:`, message);
        results.push({
          order: order || i + 1,
          type: type || 'unknown',
          success: false,
          error: `Mensagem inv√°lida: order=${order}, type=${type}`
        });
        continue;
      }
      
      try {
        console.log(`üì§ Enviando mensagem ${order} de ${sortedMessages.length} para ${number}`);
        
        let result;
        
        switch (type) {
          case 'text':
            console.log(`üîç Enviando texto processado:`, {
              originalText: content.text,
              processedText: content.text
            });
            result = await evolutionApi.sendTextMessage(
              instanceName,
              number,
              content.text
            );
            break;

          case 'image':
            result = await evolutionApi.sendMedia(
              instanceName,
              number,
              content.media,
              'image'
            );
            break;

          case 'image_caption':
            console.log(`üîç Enviando imagem com caption processado:`, {
              originalCaption: content.caption,
              processedCaption: content.caption
            });
            result = await evolutionApi.sendMedia(
              instanceName,
              number,
              content.media,
              'image',
              content.caption
            );
            break;

          case 'audio':
            result = await evolutionApi.sendAudioUrl(
              instanceName,
              number,
              content.media
            );
            break;

          case 'file':
            result = await evolutionApi.sendMedia(
              instanceName,
              number,
              content.media,
              'document',
              '',
              content.fileName
            );
            break;

          case 'file_caption':
            console.log(`üîç Enviando arquivo com caption processado:`, {
              originalCaption: content.caption,
              processedCaption: content.caption
            });
            result = await evolutionApi.sendMedia(
              instanceName,
              number,
              content.media,
              'document',
              content.caption,
              content.fileName
            );
            break;

          default:
            throw new Error(`Tipo de mensagem n√£o suportado: ${type}`);
        }

        results.push({
          order: order,
          type: type,
          success: true,
          result: result
        });

        console.log(`‚úÖ Mensagem ${order} enviada com sucesso para ${number}`);

        // Aguardar delay antes da pr√≥xima mensagem (exceto na √∫ltima)
        if (i < sortedMessages.length - 1 && delay > 0) {
          console.log(`‚è±Ô∏è Aguardando ${delay} segundos antes da pr√≥xima mensagem...`);
          await new Promise(resolve => setTimeout(resolve, delay * 1000));
        }

      } catch (error) {
        console.error(`‚ùå Erro ao enviar mensagem ${order} para ${number}:`, error.message);
        
        results.push({
          order: order,
          type: type,
          success: false,
          error: error.message
        });

        // Se uma mensagem falhar, continuar com as pr√≥ximas
        continue;
      }
    }

    return {
      success: results.some(r => r.success),
      messages: results,
      totalSent: results.filter(r => r.success).length,
      totalFailed: results.filter(r => !r.success).length
    };
  }

  /**
   * Pausa um disparo
   * @param {string} dispatchId - ID do disparo
   * @param {string} reason - Motivo da pausa
   */
  async pauseDispatch(dispatchId, reason = 'Pausado pelo usu√°rio') {
    const dispatch = await MassDispatch.findById(dispatchId);
    if (!dispatch) return;

    // Limpar timer
    if (this.timers.has(dispatchId)) {
      clearTimeout(this.timers.get(dispatchId));
      this.timers.delete(dispatchId);
    }

    // Atualizar status
    dispatch.status = 'paused';
    dispatch.isActive = false;
    dispatch.pausedAt = new Date();
    dispatch.error = reason;
    await dispatch.save();

    // Remover da lista de ativos
    this.activeDispatches.delete(dispatch.instanceName);

    // Notificar
    socketManager.emitToUser(dispatch.userId, 'mass-dispatch-paused', {
      dispatchId: dispatch._id,
      reason
    });
  }

  /**
   * Completa um disparo
   * @param {string} dispatchId - ID do disparo
   */
  async completeDispatch(dispatchId) {
    const dispatch = await MassDispatch.findById(dispatchId);
    if (!dispatch) return;

    // Limpar timer
    if (this.timers.has(dispatchId)) {
      clearTimeout(this.timers.get(dispatchId));
      this.timers.delete(dispatchId);
    }

    // Atualizar status
    dispatch.status = 'completed';
    dispatch.isActive = false;
    dispatch.completedAt = new Date();
    await dispatch.save();

    // Remover da lista de ativos
    this.activeDispatches.delete(dispatch.instanceName);

    // Notificar
    socketManager.emitToUser(dispatch.userId, 'mass-dispatch-completed', {
      dispatchId: dispatch._id,
      statistics: dispatch.statistics
    });
  }

  /**
   * Reenviar n√∫meros pendentes de um disparo
   * @param {string} dispatchId - ID do disparo
   */
  async retryPendingNumbers(dispatchId) {
    console.log(`üîÑ === INICIANDO REENVIO DE N√öMEROS PENDENTES ===`);
    console.log(`Disparo ID: ${dispatchId}`);
    
    const dispatch = await MassDispatch.findById(dispatchId);
    if (!dispatch) throw new Error('Disparo n√£o encontrado');

    console.log(`üìä Status atual do disparo:`, {
      name: dispatch.name,
      status: dispatch.status,
      isActive: dispatch.isActive,
      currentIndex: dispatch.currentIndex
    });

    const pendingNumbers = dispatch.numbers.filter(n => n.status === 'pending');
    console.log(`üìã N√∫meros pendentes encontrados: ${pendingNumbers.length}`);
    
    pendingNumbers.forEach((num, idx) => {
      console.log(`  Pendente ${idx}: ${num.original} -> ${num.formatted}`);
    });
    
    if (pendingNumbers.length === 0) {
      console.log(`‚úÖ Nenhum n√∫mero pendente encontrado`);
      return { success: true, message: 'Nenhum n√∫mero pendente encontrado' };
    }

    console.log(`üîÑ Reenviando ${pendingNumbers.length} n√∫meros pendentes`);

    // Resetar √≠ndice para o primeiro n√∫mero pendente
    const firstPendingIndex = dispatch.numbers.findIndex(n => n.status === 'pending');
    console.log(`üìç Primeiro n√∫mero pendente no √≠ndice: ${firstPendingIndex}`);
    
    dispatch.currentIndex = firstPendingIndex;
    dispatch.status = 'running';
    dispatch.isActive = true;
    await dispatch.save();
    
    console.log(`üíæ Disparo atualizado:`, {
      currentIndex: dispatch.currentIndex,
      status: dispatch.status,
      isActive: dispatch.isActive
    });

    // Registrar disparo ativo
    this.activeDispatches.set(dispatch.instanceName, dispatchId);
    console.log(`üìù Disparo registrado como ativo para inst√¢ncia: ${dispatch.instanceName}`);

    // Iniciar processo de envio
    console.log(`üöÄ Iniciando processo de envio...`);
    this.processDispatch(dispatchId);

    return { 
      success: true, 
      message: `Reenviando ${pendingNumbers.length} n√∫meros pendentes`,
      pendingCount: pendingNumbers.length
    };
  }

  /**
   * Cancela um disparo
   * @param {string} dispatchId - ID do disparo
   */
  async cancelDispatch(dispatchId) {
    const dispatch = await MassDispatch.findById(dispatchId);
    if (!dispatch) throw new Error('Disparo n√£o encontrado');

    // Limpar timer
    if (this.timers.has(dispatchId)) {
      clearTimeout(this.timers.get(dispatchId));
      this.timers.delete(dispatchId);
    }

    // Atualizar status
    dispatch.status = 'cancelled';
    dispatch.isActive = false;
    await dispatch.save();

    // Remover da lista de ativos
    this.activeDispatches.delete(dispatch.instanceName);

    // Notificar
    socketManager.emitToUser(dispatch.userId, 'mass-dispatch-cancelled', {
      dispatchId: dispatch._id
    });

    return { success: true, message: 'Disparo cancelado com sucesso' };
  }

  /**
   * Calcula pr√≥xima execu√ß√£o baseada no agendamento
   * @param {object} dispatch - Disparo
   * @returns {Date} - Pr√≥xima execu√ß√£o
   */
  calculateNextRun(dispatch) {
    const now = new Date();
    const schedule = dispatch.settings.schedule;
    
    if (!schedule.enabled) return null;

    // Implementar l√≥gica de agendamento
    // Por simplicidade, agendar para pr√≥ximo hor√°rio v√°lido
    const nextRun = new Date(now);
    nextRun.setDate(nextRun.getDate() + 1);
    
    if (schedule.startTime) {
      const [hour, minute] = schedule.startTime.split(':');
      nextRun.setHours(parseInt(hour), parseInt(minute), 0, 0);
    }

    return nextRun;
  }

  /**
   * Agenda um disparo para execu√ß√£o futura
   * @param {string} dispatchId - ID do disparo
   */
  scheduleDispatch(dispatchId) {
    // Implementar agendamento com cron ou similar
    console.log(`Disparo ${dispatchId} agendado`);
  }

  /**
   * Lista disparos do usu√°rio
   * @param {string} userId - ID do usu√°rio
   * @returns {Array} - Lista de disparos
   */
  async getUserDispatches(userId) {
    return await MassDispatch.find({ userId })
      .sort({ createdAt: -1 })
      .populate('userId', 'name email');
  }

  /**
   * Obt√©m estat√≠sticas gerais
   * @param {string} userId - ID do usu√°rio
   * @returns {object} - Estat√≠sticas
   */
  async getUserStats(userId) {
    const dispatches = await MassDispatch.find({ userId });
    
    const stats = {
      total: dispatches.length,
      running: dispatches.filter(d => d.status === 'running').length,
      completed: dispatches.filter(d => d.status === 'completed').length,
      paused: dispatches.filter(d => d.status === 'paused').length,
      totalMessagesSent: dispatches.reduce((sum, d) => sum + d.statistics.sent, 0),
      totalMessagesFailed: dispatches.reduce((sum, d) => sum + d.statistics.failed, 0)
    };

    return stats;
  }
}

module.exports = new MassDispatchService();
